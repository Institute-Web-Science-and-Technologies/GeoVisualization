\subsection*{Spiellogik}

\subsubsection*{Server}
Der Server wird hier noch mit einer Zusatzfunktion ausgestattet, er generiert nach vorher festgelegten Bedingungen gültige Flaggenpunkte. Für unser Spiel entschieden wir uns, nur normale Straßen (keine Bundesstraßen oder Autobahnen) als Flaggenkoordinaten zuzulassen. Innenräume können Probleme hinsichtlich der GPS-Genauigkeit und Erreichbarkeit verursachen und wir wollten unser Spiel für die Innenstadt programmieren, d.h. Grünflächen schieden ebenfalls aus. Warum wir keine Wasserflächen und Gebirge wollten ist selbsterklärend.\newline Unser Server erstellt eine zufällige Koordinate in einem Radius um die eigene Basis. Dann fordert er von GoogleStaticMaps ein 1 Pixel großes Bild an der eben kreirten Koordinate auf maximalem Zoom an und führt eine Farberkennung durch, um zu überprüfen, ob die Koordinate die Farbe einer Straße hat. Ist dies der Fall schickt der Server die Koordinate als neue Flaggenposition an die Smartphones zurück. Andernfalls wiederholt der Server den Vorgang der Positionsgenerierung und des Testens so lange, bis er eine gültige Position gefunden hat.

\subsubsection*{Client}
Auf der Client-Seite wird die Sichtbarkeit der Spieler und Objekte (Flaggen und Basen) gehandhabt.

\paragraph{Markieren:}
 Sämtliche Positionen sind den Geräten bekannt, aber nicht alle sichtbar. Damit verbunden sind auch die Funktionalitäten des Markieren und Scannens. Für das Markieren werden jeweils die beiden Koordinaten des Markierenden (A) und des Markierten (B), sowie den Sichtkegel von A und eine Reichweite benötigt. 
Für den Sichtkegel benötigt man einen Orientierungswinkel ($\alpha$), welche mittels der Sensoren für Orientierung (s. \ref{orientierung}) ermittelt wird, sowie einen vorher festgelegten Winkel für den Sichtbereich ($\beta$). Nun wird der Winkel der beiden Punkte A und B ($\gamma$) bestimmt (s. \ref{abstandsmessung}).


Liegt $\gamma$ im Intervall $[ \alpha - \frac{\beta}{2}; \alpha + \frac{\beta}{2}]$ und ist die Distanz zwischen A und B innerhalb der Reichweite, so gilt B als markiert. Über eine Nachricht wird den anderen Teammitgliedern mitgeteilt, dass B jetzt markiert und somit für eine gewisse Zeit sichtbar ist. A kann nach Benutzung (auch wenn niemand markiert wird) für eine vordefinierte Zeit keine weiteren Gegner markieren.

\paragraph{Scannen:}

Um einen festgelegten Radius eines Spielers nach Gegnern zu scannen, wird die Distanz (s. \ref{abstandsmessung}) zwischen dem Scannenden (C) und allen gegnerischen Spielern ermittelt. C werden, für eine kurze Zeit, alle gegnerischen Spieler angezeigt, die sich innerhalb eines bestimmten Distanzwertes befinden. Die Möglichkeit zu Scannen steht C für eine gewisse Zeit nicht mehr zur Verfügung.

\paragraph{Geschwindigkeitsüberprüfung:}
Es existiert eine ständig aktive Geschwindigkeitsüberprüfung der Spieler durch ihre Koordinaten (s. \ref{locationManager}). Wenn eine feste Maximalgeschwindigkeit durch einen Spieler überschritten wird, schickt der entsprechende Client eine Nachricht an alle gegnerischen Geräte, dass dieser angezeigt werden soll. Wird die Maximalgeschwindigkeit wieder unterschritten, ist der Betroffene wieder unsichtbar für die Gegner

\paragraph{Basen- und Flaggenplatzierung:}
Die Basis eines Teams wird vom ersten Teammitglied gesetzt, welches auf den "`set Base"' Button klickt. Als Zentrum wird die momentane Position des Spielers genommen. Die Darstellung erfolgt als Kreis. Nun wird in einem vorher festgelegtem Radius um die Basis zufällig die Teamflagge platziert. Die Auswahl für eine gültige Koordinate trifft dabei der Server und teilt dies den entsprechenden Mitspielern über eine Nachricht mit. Die aktuelle Position der Flagge wird jedoch dem eigenen Team nicht angezeigt. Wird die Flagge von einem Mitspieler des gegnerischen Team gestohlen, werden die betroffenen Spieler über einen Vibrationsalarm informiert. Außerdem wird die letzte Position der Flagge vorläufig angezeigt. Wenn der Flaggenträger markiert wird, verliert er die Flagge und der Server generiert eine neue Flaggenposition.
