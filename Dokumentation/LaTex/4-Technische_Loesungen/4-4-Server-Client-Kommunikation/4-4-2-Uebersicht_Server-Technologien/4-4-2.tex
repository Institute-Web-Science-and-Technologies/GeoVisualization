
\subsection*{Kommunikations-Technologien}


%Die Kommunikation zwischen Client und Server kann als Push- oder Pull-Kommunikation realisiert werden. 
%Bei der Pull-Kommunikation fordert der Client die benötigten Informationen vom Server an. Im Falle einer Echtzeitanwendung muss dies in regelmäßigen Abständen geschehen.
%Bei der Push-Kommunikation sendet der Server, wenn sich der Zustand ändert, unaufgefordert Informationen an die betroffenen Clients.

%Pull-Kommunikation über HTTP-Requests umgesetzt hat eine nicht hinnehmbare Verzögerung bewirkt.
%Die finale Implementation verwendet daher Push-Kommunikation. 

%Eine spezialisierte Server-Architektur, die \textit{message passing} mit Push-Kom\-mu\-ni\-ka\-tion umsetzt, ist XMPP \cite{xmpp}. Es wurde jedoch eine allgemeine Server-Lösung bevorzugt, um die Flexibilität zu erhöhen und notfalls Berechnungen auf den Server auslagern zu können.
%Im Falle mobiler Endgeräte muss Push-Kommunikation über Sockets laufen, da diese nicht zuverlässig über eine IP-Adresse angesprochen werden können.
%Wir haben die Publish-Subscribe-Architektur jeweils mit Hilfe von WebSockets und ZeroMQ\footnote{\url{http://zeromq.org/}} umgesetzt und beide Ansätze verglichen. 
%Die auf WebSockets aufbauende Lösung haben wir mit Node.js\footnote{\url{https://nodejs.org/}} implementiert.
%Die andere Lösung verwendet
%JeroMQ\footnote{\url{https://github.com/zeromq/jeromq}}, eine Implementation von ZeroMQ in Java. 
%Wir haben uns für JeroMQ entschieden, da es so möglich war, den Server in Java umzusetzen und so Server und Client in der selben Programmiersprache zu implementieren.

Zu Beginn haben wir mit einem Node.js Server \footnote{\url{https://nodejs.org/}} und URLConnection \footnote{\url{http://developer.android.com/reference/java/net/URLConnection.html}} auf der Client-Seite experimentiert. Dies wurde jedoch aufgrund langer Antwortzeiten verworfen. 
In einem weiterem Experiment wurde ZeroMQ verwendet. Dafür wurde der Server in Java mit JeroMQ\footnote{\url{https://github.com/zeromq/jeromq}} realisiert. Es wurden weitaus kürzere Antwortzeiten erreicht (mehrere tausend Nachrichten pro Sekunde in unseren Tests), weshalb wir uns für diese Lösung entschieden. Zudem ist ZeroMQ äußerst einsteigerfreundlich und asynchron, d.h. es muss nicht auf eine Antwort warten, bevor es neue Nachrichten empfangen kann, was eine Bedingung für das Spielen mit mehreren Spielern ist. 
%@Nils: pro contra für Node.js adden
