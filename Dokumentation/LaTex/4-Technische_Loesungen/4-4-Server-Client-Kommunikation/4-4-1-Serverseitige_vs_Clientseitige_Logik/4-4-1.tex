

\subsection*{Serverseitige und clientseitige Logik}


Um den Zustand der einzelnen mobilen Geräte zu synchronisieren und Chat-Nachrichten zu übertragen, ist ein Server nötig. Die Kommunikation ausschließlich zwischen mobilen Endgeräten kann sich sonst als schwierig erweisen, da sich deren IP-Adresse jederzeit ändern kann. Die Einrichtung eines Servers, der die Kommunikation regelt ist folglich sinnvoll. 

Hierzu bieten sich zwei unterschiedliche Modelle an.
Eine Möglichkeit wäre eine serverlastige Server-Client-Architektur. Hierbei übernehmen die Clients einen möglichst geringen Teil der Berechnungen und Logik. Sie werden als Thin-Clients bezeichnet. Den Großteil der Berechnungen übernimmt der Server. In einer möglichen Implementation hält der Server einen zentralen, für alle gültigen Status.
Die Thin-Clients übertragen die Nutzereingaben und Sensordaten an den Server, der daraus einen neuen Zustand ermittelt und diesen den Clients mitteilt.

Alternativ kann man Berechnungen und Logik vorrangig clientlastig implementieren. Diese werden dann Fat-Clients genannt. 
 Dies fordert leistungsfähigere Endgeräte, während der Server entlastet wird. 
Aktuelle Smartphones könnten die entwickelte Anwendung jedoch mühelos ausführen.
Eine clientlastige  Implementation hätte außerdem den Vorteil, dass bei vielen Nutzern die Rechenleistung hauptsächlich auf die Clients verteilt wird und dementsprechend der Server weniger leistungsstark sein muss. 
%Diese haben sich als genügend leistungsfähig erwiesen.
Bei fast jeder Änderung muss jeder Client seinen Zustand selbst\-stän\-dig aktualisieren, da die Programmlogik auf jedem Client vorliegt. Eine clientlastige Implementation verringert Wartbarkeit und Erweiterbarkeit. Da die Implementation definitiv eine Internetverbindung benötigt, könnte der Server mit einer Update-Funktionalität versehen werden. Auch könnte dieses Problem, bei entsprechender Produktreife, über die Aktualisierungsmöglichkeit von App-Stores gelöst werden. In Mehrspieleranwendungen kommt zusätzlich hinzu, dass es keinen definitiven, zentralen Zustand gibt und auf verschiedenen Clients zum gleichen Zeitpunkt unterschiedliche Zustände vorliegen können. Da diese Zustände für Berechnungen genutzt werden, kann dies zu Unklarheiten und Fehlern führen, die abgefangen werden müssen.
%Wir haben abgeschätzt, dass wir mit Fat-Clients Internet-Bandbreite sparen können, da kleinere Daten übertragen werden müssen. 

\begin{center}
\begin{tabular}{l|l}
	Thin-Client & Fat-Client \\
	\hline

	 \,--\, Zustand doppelt modelliert & + Server-Zustand nicht nötig \\
	 + zentraler, definitiver Zustand &  \,--\, verteilter Zustand \\
	 \,--\, hohe Serverlast & + niedrige Serverlast \\
	 + Wartbarkeit & \,--\, Wartbarkeit \\
	 + Erweiterbarkeit & \,--\, Erweiterbarkeit \\
\end{tabular}
\end{center}

\subsection*{Publish-Subscribe-Pattern}
Das Publish-Subscribe-Pattern ist ein Entwurfsmuster für Server"=Client"=Kommunikation. Es gleicht dem Beobachter-Muster (\textit{observer pattern}).
Die Kommunikation zwischen Server und Client wird dabei als Push"=Kommunikation umgesetzt:
Die Clients nehmen die Rolle des Subscribers ein. Jeder Client meldet sich beim Server, der in der Rolle des Publishers fungiert, für bestimmte Typen von Nachrichten an. Tritt ein bestimmtes Ereignis auf, beispielsweise eine Änderung des Server-Zustands, informiert der Server aktiv alle Clients, die diese Art Ereignis abonniert haben, und schickt jedem eine Nachricht \cite{xmpp, eugster}.


\subsection*{Push- versus Pull Kommunikation}
Bei der Push-Kommunikation sendet der Server von sich aus Informationen. Zum Beispiel wenn ein Update bereitsteht. Im Fall unserer Implementation würde der Server ein Positionsupdate eines Spielers erhalten und dieses sofort an alle anderen Spieler weiterleiten. Dies hat den Vorteil, dass die Informationen so zeitnah wie möglich an alle Spieler übertragen werden. Dadurch kann bei Spielen in Echtzeit sichergestellt werden, dass bei jeder Spielerhandlung alle anderen Clients möglichst schnell aktualisiert werden.

Im Gegensatz dazu wird bei der Pull-Kommunikation der Server ausschließlich auf Anfrage eines Clients aktiv. Falls der Client nicht bloß einzelne Berechnungen auf den Server auslagern soll, sondern Informationen über externe Ereignisse braucht, muss er in regelmäßigen Abständen diese Informationen beim Server anfragen.
Bei sinnvoller Implementation hat man deutlich weniger Updates als bei der Push Kommunikation und benötigt daher weniger Bandbreite. 
Da für unsere Echtzeit-Spiele update-Geschwindigkeit enorm wichtig ist und wir so zeitnah Updates schicken wollten wie möglich, haben wir uns für die Push-Kommunikation entschieden. Wir realisieren diese Push-Kommunikation mit einem Entwurfsmuster für Server-Client-Kommunikation, dem Publish-Subscribe-Pattern (siehe vorheriger Abschnitt).

%Verlgeich mit Observerpattern

%Die Kommunikation zwischen Server und Client haben wir mit Hilfe von \textit{message passing} realisiert. \textit{Message passing} ist eine Variante des Publish"=Subscribe"=Patterns, bei dem der Server keinen Zustand hält, sondern bloß eingehende Nachrichten an alle Clients weiterleitet, die den entsprechen Nachrichtentyp abonniert haben.
%Dabei werden alle Berechnungen vom Client ausgeführt.
%Dadurch verringert sich die Komplexität der Anwendung, da der Zustand nicht doppelt modelliert werden muss. Dies macht die Anwendung weniger fehleranfällig \cite{eugster}.\textbf{}

%Nicht das was in der Quelle steht.
