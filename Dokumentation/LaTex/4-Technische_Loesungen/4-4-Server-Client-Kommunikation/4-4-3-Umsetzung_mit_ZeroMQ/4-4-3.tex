\subsection{Umsetzung mit ZeroMQ}


Für Echtzeit-Spiele benötigt man eine mehr oder weniger {\color{red}'mehr oder weniger' streichen} permanente Datenübertragung. Nicht nur weil langsame Updates irreführend sein können, sondern insbesondere wenn man mit mehreren Spielern gegeneinander spielt und die Versionen nicht synchron sind. Bei Verstecken etwa könnte ein um sechs Sekunden verspätetes Update dazu führen, dass man nach einer Richtungsänderung glaubt, in die richtige Richtung zu gehen, obwohl das Update vorher hätte eintreffen sollen. Bei Snake kann man z.B. durch eine Schlange laufen, ohne eine Kollision zu bekommen, wenn die eigene Version überzeugt ist, dass da noch keine Schlange ist, weil der Zustand des Spiels auf dem eigenen Smartphone noch nicht aktuell ist. 

Generell kann man davon ausgehen, dass je schneller das Spiel ist und je mehr virtuelle Objekte einbezogen werden, desto häufiger und schneller müssen Updates kommen. Daher wollten wir eine Übertragung, die performant ist, schnell viele Nachrichten senden kann und außerdem asynchron Nachrichten verarbeitet, also nicht jedes mal auf eine Antwort des Empfängers wartet, bevor eine weitere Nachricht abgeschickt werden kann.

ZeroMQ kann all das. In unseren Probeläufen war ZMQ (ZeroMQ) in der Lage, mehrere Tausend Nachrichten innerhalb einer Sekunde abzuschicken. ZMQ arbeitet standardmäßig asynchron. Außerdem sendet ZMQ Nachrichten erneut, falls die Nachricht beim ersten Senden nicht an kam, sodass es relativ unwahrscheinlich wird, dass eine Nachricht komplett ausfällt und Spieler mit zwei unterschiedlichen Versionen spielen. Das ermöglicht eine relativ kleine Serverarchitektur, da der Server nicht eine Version des momentanen Spiels speichern muss. Außerdem ist es recht einsteigerfreundlich. Das alles machte es für unsere Test-Apps zum idealen Kandidaten.


Hier kommen Vergleiche zwischen ZMQ und seinen Konkurrenten (andere messaging Protokolle) hin.
